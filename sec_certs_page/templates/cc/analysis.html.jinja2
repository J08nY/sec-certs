{% extends "crowdsourced.html.jinja2" %}
{% set crumbs = True %}
{% set search = True %}
{% set canonical = True %}
{% block title %}
    <title>Common Criteria analysis | sec-certs.org</title>
{% endblock %}
{% block content %}
    <main>
        <div class="col-12 col-sm-10 mx-auto p-3 py-md-5">
            <div class="alert alert-warning d-sm-none" role="alert">
                <i class="fas fa-exclamation-triangle"></i> This page was not yet optimized for use on mobile devices.
            </div>
            <h1 class="mb-4">Common Criteria</h1>
            <p class="lead">This is a very basic showcase of some of our statistics.
            For more, see our <a href="{{ url_for("about", _anchor="research") }}">research</a> and
                the <a href="https://sec-certs.org/docs/notebooks/examples/est_solution.html">notebooks</a> in our documentation.
            </p>
            <div class="row mt-4 mb-4" data-cs-name="Categories plot">
                <div class="col border ml-3 mr-3">
                    <h2>Categories</h2>
                    <div id="categories"></div>
                </div>
            </div>
            <div class="row mt-4 mb-4" data-cs-name="Certified items plot">
                <div class="col border ml-3 mr-3">
                    <h2>Certified</h2>
                    <div id="certified"></div>
                </div>
            </div>

            <script>
                function renderCategories(data) {
                    let pie = d3.pie()
                        .sort(null)
                        .value(d => d.value);
                    let width = 800;
                    let height = 320;
                    const radius = 150;
                    let arc = d3.arc()
                        .innerRadius(0)
                        .outerRadius(radius);
                    let color = d3.scaleOrdinal()
                        .domain(data.map(d => d.name))
                        .range(d3.quantize(t => d3.interpolateTurbo(t * 0.8 + 0.1), data.length).reverse())

                    let legend = d3.legendColor()
                        .shape("circle")
                        .shapeRadius(7)
                        .shapePadding(20)
                        .scale(color);

                    const arcs = pie(data);

                    const svg = d3.create("svg")
                        .attr("viewBox", [-width / 2, -height / 2, width, height]);

                    svg.append("g")
                        .attr("transform", `translate(-${width / 4},0)`)
                        .attr("stroke", "white")
                        .selectAll("path")
                        .data(arcs)
                        .join("path")
                        .attr("fill", d => color(d.data.name))
                        .attr("d", arc)
                        .append("title")
                        .text(d => `${d.data.name}: ${d.data.value.toLocaleString()}`);

                    svg.append("g")
                        .attr("font-size", "10px")
                        .attr("class", "legend")
                        .attr("fill", "currentColor")
                        .attr("transform", `translate(10,-${height / 2 - 20})`)
                        .call(legend);

                    d3.select("#categories").append(() => svg.node());
                }

                let catData = JSON.parse('{{ analysis["categories"]|tojson }}');

                renderCategories(catData);

                function renderCertified(data, categories) {
                    for (let i in data) {
                        data[i].date = new Date(data[i].date);
                    }
                    let catNames = categories.map(d => d.name);
                    let series = d3.stack().keys(catNames)(data)

                    let width = 800;
                    let height = 320;
                    let margin = {top: 20, right: 30, bottom: 30, left: 40};

                    let x = d3.scaleUtc()
                        .domain(d3.extent(data, d => d.date))
                        .range([margin.left, width - margin.right]);
                    let y = d3.scaleLinear()
                        .domain([0, d3.max(series, d => d3.max(d, d => d[1]))]).nice()
                        .range([height - margin.bottom, margin.top]);
                    let color = d3.scaleOrdinal()
                        .domain(catNames)
                        .range(d3.quantize(t => d3.interpolateTurbo(t * 0.8 + 0.1), catNames.length).reverse());
                    let xAxis = g => g
                        .attr("transform", `translate(0,${height - margin.bottom})`)
                        .call(d3.axisBottom(x).ticks(width / 80).tickSizeOuter(0));
                    let yAxis = g => g
                        .attr("transform", `translate(${margin.left},0)`)
                        .call(d3.axisLeft(y))
                        .call(g => g.select(".domain").remove());
                    let area = d3.area()
                        .defined(d => !isNaN(d[0]) && !isNaN(d[1]))
                        .x(d => x(d.data.date))
                        .y0(d => y(d[0]))
                        .y1(d => y(d[1]));

                    const svg = d3.create("svg")
                        .attr("viewBox", [0, 0, width, height]);

                    svg.append("g")
                        .selectAll("path")
                        .data(series)
                        .join("path")
                        .attr("fill", ({key}) => color(key))
                        .attr("d", area);

                    svg.append("g")
                        .call(xAxis);

                    svg.append("g")
                        .call(yAxis);

                    d3.select("#certified").append(() => svg.node());
                }

                let certifiedData = JSON.parse('{{ analysis["certified"]|tojson }}');

                renderCertified(certifiedData, catData);
            </script>
        </div>
    </main>

{% endblock %}
