{% macro render_network(net_url, type_url, width=600, height=600, linkDistance=30, linkCharge=-100, forceCenter=False, highlight=[]) %}
    <style>
        #network {
            width: 100%;
            margin: auto;
        }
    </style>
	<div id="network"></div>
	<script>
    function renderNetwork(data, types, highlighted) {
        let height = {{ height }};
        let width = {{ width }};
        let color = d => {
            if (highlighted.includes(d.id)) {
                return "#d62728"
            } else {
                return "#0d6efd"
            }
        }
        let drag = simulation => {
            function dragstarted(event) {
                if (!event.active) simulation.alphaTarget(0.3).restart();
                event.subject.fx = event.subject.x;
                event.subject.fy = event.subject.y;
            }

            function dragged(event, d) {
                event.subject.fx = event.x;
                event.subject.fy = event.y;
            }

            function dragended(event) {
                if (!event.active) simulation.alphaTarget(0);
                event.subject.fx = null;
                event.subject.fy = null;
            }

            return d3.drag()
                .on("start", dragstarted)
                .on("drag", dragged)
                .on("end", dragended);
        }

        const links = data.links.map(d => Object.create(d));
        const nodes = data.nodes.map(d => Object.create(d));

        const simulation = d3.forceSimulation(nodes)
          .force("link", d3.forceLink(links).id(d => d.id).distance({{ linkDistance }}).strength(1))
          .force("charge", d3.forceManyBody().strength({{ linkCharge }}))
          .force("x", d3.forceX(width/2))
          .force("y", d3.forceY(height/2));

        const zoom = d3.zoom().extent([[0, 0], [width, height]]).scaleExtent([0.25, 4]).on("zoom", zoomed);

        const svg = d3.create("svg")
            .attr("viewBox", [0, 0, width, height])
            .style("font", "12px");

        const defs = svg.append("defs");

        defs.selectAll("marker")
            .data(["default"])
            .join("marker")
            .attr("id", d => d)
            .attr("viewBox", "0 -5 10 10")
            .attr("refX", 25)
            .attr("refY", 0)
            .attr("markerWidth", 6)
            .attr("markerHeight", 6)
            .attr("orient", "auto")
            .append("path")
            .attr("fill", "#888")
            .attr("fill-opacity", 0.6)
            .attr("d", "M0,-5L10,0L0,5");

        let dTypes = Object.keys(types).map(type => types[type]);

        defs.selectAll("g")
            .data(dTypes)
            .join("g")
            .attr("id", d => d.id)
            .attr("viewBox", "0 0 512 512")
            .attr("transform", "translate(-12, -10) scale(0.05)")
            .html(d => d.svg)

        const g = svg.append("g");

        svg.append("text")
            .attr("fill", "#000")
            .attr("x", 5)
            .attr("y", 15)
            .text("Nodes: " + nodes.length);

        svg.append("text")
            .attr("fill", "#000")
            .attr("x", 5)
            .attr("y", 30)
            .text("Edges: " + links.length);

        const link = g.append("g")
            .attr("stroke", "#888")
            .attr("stroke-opacity", 0.6)
            .selectAll("line")
            .data(links)
            .join("line")
            .attr("stroke-width", d => Math.sqrt(d.value))
            .attr("marker-end", "url(" + new URL("#default", location) + ")");

        const node = g.append("g")
            .selectAll("g")
            .data(nodes)
            .join("g")
            .call(drag(simulation));

        node.append("a")
            .attr("href", d => d.href)
            .append("use")
            .attr("xlink:href", d => "#" + d.type)
            .attr("fill", color);

        const text = node.append("text")
            .attr("fill", "#000")
            .attr("visibility", "hidden");

        text.append("tspan")
            .text(d => d.certid)
            .attr("x", 20)
            .attr("y", "0.2em");

        text.append("tspan")
            .text(d => d.name)
            .attr("x", 20)
            .attr("y", "1.2em");

        svg.call(zoom).call(zoom.transform, d3.zoomIdentity);

        function zoomed({transform}) {
            g.attr("transform", transform);
        }

        let closest = null;

        svg.on("mousemove", event => {
            let transform = d3.zoomTransform(g.node());
            let ptr = d3.pointer(event, svg.node());
            ptr = transform.invert(ptr);
            let x = ptr[0];
            let y = ptr[1];
            let newClosest = simulation.find(x, y);
            if (newClosest !== closest) {
                node.each(function (d, i) {
                    if (i === newClosest.index) {
                        d3.select(this).select("text").attr("visibility", null);
                        d3.select(this).select("use").attr("fill", "#000");
                    } else if (closest !== null && i === closest.index) {
                        d3.select(this).select("text").attr("visibility", "hidden");
                        d3.select(this).select("use").attr("fill", color);
                    }
                });
                closest = newClosest;
            }
        });

        simulation.on("tick", () => {
            link
                .attr("x1", d => d.source.x)
                .attr("y1", d => d.source.y)
                .attr("x2", d => d.target.x)
                .attr("y2", d => d.target.y);

            node
                .attr("transform", d => d3.zoomIdentity.translate(d.x, d.y));
        });

        d3.select("#network").append(() => svg.node());
    }

    let highlighted = {{ highlight|safe }};

	Promise.all([d3.json("{{ net_url }}"), d3.json("{{ type_url }}")]).then(values => {
	    let data = values[0];
	    let types = values[1];
        if (("nodes" in data) && ("links" in data)) {
            renderNetwork(data, types, highlighted);
        } else {

        }
    });
	</script>
{%- endmacro %}